##### Linux常用命令

###### 		常见的文件操作工具
​		chown/chmod/chgrp
​		ls/rm/cd/cp/mv/touch/rename/In(软链接和硬链接)等
​		locate/find/grep定位查找和搜索

###### 	文件或者日志查看工具

​		编辑器vi/nano
​		cat/head/tail查看文件
​		more/less交互式查看文件

###### 	常见的进程操作工具

​		ps查看进程
​		kil杀死进程
​		top/htop监控进程

###### 	常见的内存操作工具

​		free查看可用内存
​		了解每一列的具体含义
​		排查内存泄露问题

###### 	常见的网络工具

​		ifconfig查看网卡信息
​		lsof/netstat查看端口信息
​		ssh/scp远程登录/复制。tcpdump 抓包

###### 	常见用户和组操作

​		useradd/usermod
​		groupadd/groupmod

##### 进程和线程的区别

###### 	进程和线程对比

​		进程是对运行时程序的封装，是系统资源调度和分配的基本单位
​		线程是进程的子任务, cpu调度和分配的基本单位，实现进程内并发
​		一个进程可以包含多个线程，线程依赖进程存在，并共享进程内存

##### 什么是线程安全

###### 	Python哪些操作是线程安全的?

​		一个操作可以在多线程环境中安全使用，获取正确的结果
​		线程安全的操作好比线程是顺序执行而不是并发执行的(i+= 1)
​		一般如果涉及到写操作需要考虑如何让多个线程安全访问数据

##### 线程同步的方式

###### 	了解线程同步的方式，如何保证线程安全

​		互斥量（锁):通过互斥机制防止多个线程同时访问公共资源
​		信号量(Semphare):控制同一时刻多个线程访问同一个资源的线程数
​		事件(信号):通过通知的方式保持多个线程同步

##### 进程间通信的方式

###### 	Inter-Process Communication 进程间传递信号或者数据

​		管道/匿名管道/有名管道(pipe)
​		信号(Signal): 比如用户使用Ctrl+c产生SIGINT程序终止信号
​		消息队列(Message)
​		共享内存(share memory)
​		信号量(Semaphore)
​		套接字(socket)∶最常用的方式，我们的web应用都是这种方式

##### Python中如何使用多线程

###### 	threading模块

​		threading.Thread类用来创建线程
​		start()方法启动线程
​		可以用join()等待线程结束

##### Python中如何使用多进程

###### 	Python有GIL，可以用多进程实现cpu密集程序

​		multiprocessing多进程模块
​		Multiprocessing.Process类实现多进程
​		一般用在cpu密集程序里，避免GIL的影响

##### 什么是分页机制

​		操作系统为了高效管理内存，减少碎片

###### 	逻辑地址和物理地址分离的内存分配管理方案

​		程序的逻辑地址划分为固定大小的页(Page)
​		物理地址划分为同样大小的帧(Frame)
​		通过页表对应逻辑地址和物理地址

###### 	分段是为了满足代码的一些逻辑需求

​		数据共享，数据保护，动态链接等
​		通过段表实现逻辑地址和物理地址的映射关系
​		每个段内部是连续内存分配，段和段之间是离散分配的

###### 	分页与分段的区别

​		页是出于内存利用率的角度提出的离散分配机制
​		段是出于用户角度，用于数据保护、数据隔离等用途的管理机制
​		页的大小是固定的，操作系统决定﹔段大小不确定，用户程序决定

##### 什么是虚拟内存

###### 	通过把一部分暂时不用的内存信息放到硬盘上

​		局部性原理，程序运行时候只有部分必要的信息装入内存
​		内存中暂时不需要的内容放到硬盘上
​		系统似乎提供了比实际内存大得多的容量，称之为虚拟内存

##### 什么是内存抖动（颠簸)

###### 	本质是频繁的页调度行为

​		频繁的页调度，进程不断产生缺页中断
​		置换一个页，又不断再次需要这个页
​		运行程序太多﹔页面替换策略不好。终止进程或者增加物理内存

##### Python的垃圾回收机制原理?

###### 	Python无需我们手动回收内存?它的垃圾回收是如何实现的呢?

​		引用计数为主（缺点∶循环引用无法解决)
​		引入标记清除和分代回收解决引用计数的问题
​		引用计数为主+标记清除(Mark and Sweep)和分代回收为辅

| 什么时候引用计数增加呢? | 什么时候引用计数会减少呢?            |
| ----------------------- | ------------------------------------ |
| 对象创建a=1             | 显示使用del a                        |
| 对象被引用b=a           | 引用指向了别的对象b=None             |
| 对象作为参数传递func(a) | 离开的对象的作用域(比如函数执行结束) |
| 对象存储在容器中l=[a]   | 从一个容器移除对象或者销毁容器       |

```python
#引用计数
sys.getrefCount(a) #存在小整数对象池
#分代回收
gc.get_threshold()
```

